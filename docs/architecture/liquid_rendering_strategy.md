# Liquid Rendering Strategy & Page Parts

**Last Updated**: 2026-01-15
**Context**: PropertyWebBuilder (PWB) uses Liquid templating to separate content structure from data, allowing for safe, user-editable page sections.

---

## 1. Overview

PWB uses the **Liquid** templating engine (by Shopify) to manage "Page Parts" â€” the building blocks of a website's content (e.g., Hero sections, About Us text, Contact forms).

*   **Templates**: Stored as Liquid markup strings in the database (`pwb_page_parts` table) or defined in seed files (`db/yml_seeds/page_parts/*.yml`).
*   **Data**: User content (text, image URLs, links) is stored as JSON in the `block_contents` column.
*   **Rendering**: Rails merges the Template + Data to produce HTML, which is then cached in the `pwb_contents` table.

## 2. Core Workflow (Backend)

The logic is centralized in `app/services/pwb/page_part_manager.rb`.

1.  **Definition**: A seed file defines a part (e.g., `home__heroes_hero_centered.yml`) with a Liquid `template` and a default `editor_setup` (defining fields like Title, Subtitle, CTA).
2.  **Storage**: When seeded, this creates a `Pwb::PagePart` record.
3.  **Content Entry**: When a user edits a page, they update the JSON data.
4.  **Rendering**:
    ```ruby
    # Simplified rendering logic
    liquid_template = Liquid::Template.parse(page_part.template)
    html_output = liquid_template.render("page_part" => user_json_data)
    ```
5.  **Caching**: The resulting `html_output` is saved to the `raw` column of the `Pwb::Content` model. This allows for fast retrieval without re-parsing Liquid on every request.

### Custom Extensions

PWB extends Liquid with custom tags and filters:
*   `{% property_card %}`: Renders a property listing card.
*   `{% contact_form %}`: Renders a form.
*   `{% page_part "key" %}`: Composes other parts inline.
*   `{{ url | localize_url }}`: Prepend locale to paths.

## 3. Astro.js Client Integration

**The Astro client does NOT need to parse Liquid.**

The architecture is designed so that the Rails backend handles all templating complexity. The API delivers pre-rendered HTML to the client.

### API Response Structure
When the Astro client fetches page data (e.g., `GET /api_public/v1/pages/:slug?include_rendered=true`), the response looks like this:

```json
{
  "id": 123,
  "slug": "home",
  "page_contents": [
    {
      "page_part_key": "heroes/hero_centered",
      "visible": true,
      "sort_order": 1,
      "rendered_html": "<section class=\"pwb-hero\"><h1>Welcome...</h1></section>",
      "label": "Hero Section"
    },
    {
      "page_part_key": "content/basic_text",
      "visible": true,
      "sort_order": 2,
      "rendered_html": "<div class=\"pwb-content\">...</div>",
      "label": "Main Content"
    }
  ]
}
```

### Client Responsibility
1.  **Fetch**: Call the API to get the page data.
2.  **Iterate**: Loop through `page_contents`.
3.  **Inject**: Insert the `rendered_html` into the DOM.
    *   **Astro**: `<div set:html={content.rendered_html} />`
    *   **React**: `<div dangerouslySetInnerHTML={{ __html: content.rendered_html }} />`

### Why this approach?
*   **Performance**: Parsing Liquid in the browser (JS) is slower and requires a heavy library.
*   **Consistency**: Ensures the HTML structure is identical whether rendered by Rails (B-Themes) or Astro (A-Themes).
*   **Security**: HTML is sanitized and generated by the trusted backend.

## 4. Key Files

*   **Configuration**: `config/initializers/liquid.rb`
*   **Rendering Logic**: `app/services/pwb/page_part_manager.rb`
*   **API Delivery**: `app/controllers/api_public/v1/pages_controller.rb`
*   **Custom Tags**: `app/lib/pwb/liquid_tags/`

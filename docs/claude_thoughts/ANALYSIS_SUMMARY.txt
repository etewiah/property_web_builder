================================================================================
MULTI-TENANCY IMPLEMENTATION ANALYSIS - SUMMARY
PropertyWebBuilder Rails Project
================================================================================

ANALYSIS COMPLETED: Three comprehensive documents have been created:

1. MULTI_TENANCY_ANALYSIS.md (16 sections, ~600 lines)
   - Detailed technical analysis of current implementation
   - Strengths, weaknesses, and risk assessment
   - Acts-as-tenant gem evaluation
   - Recommended improvements with priorities

2. MULTI_TENANCY_QUICK_REFERENCE.md (~400 lines)
   - Developer quick reference guide
   - How to properly scope queries
   - Common patterns and anti-patterns
   - Testing examples and debugging tips

3. MULTI_TENANCY_ARCHITECTURE.md (~400 lines)
   - Visual diagrams and flowcharts
   - Request flow explanation
   - Data model relationships
   - Performance characteristics

================================================================================
KEY FINDINGS
================================================================================

CURRENT APPROACH: Hybrid Manual/Automatic
- Subdomain-based tenant resolution (SubdomainTenant concern)
- Thread-local storage via Pwb::Current.website (ActiveSupport::CurrentAttributes)
- Manual where(website_id: ...) filtering in controllers
- ScopedModel concern exists but is NOT actively used

MULTI-TENANCY PATTERN:
┌─ Request arrives at subdomain (e.g., site1.example.com)
├─ SubdomainTenant extracts subdomain → "site1"
├─ Looks up Pwb::Website by subdomain
├─ Stores in Pwb::Current.website (thread-local)
├─ Controllers query: Model.where(website_id: current_website.id)
└─ Only current website's data returned

RISK LEVEL: MEDIUM
- Current code mostly follows safety patterns
- But lacks enforcement mechanisms
- Relies on developer discipline
- Single mistake could leak cross-tenant data
- No automated tests for tenant isolation

================================================================================
STRENGTHS
================================================================================

✅ Clear tenant model (Pwb::Website)
✅ Consistent foreign key pattern (website_id on all models)
✅ Subdomain-based routing provides natural isolation
✅ Thread-local storage (CurrentAttributes) is clean
✅ Most controllers properly filter by website_id
✅ Good separation between SiteAdmin (single-tenant) and TenantAdmin (multi-tenant)
✅ GraphQL API supports X-Website-Slug header for tenant selection
✅ Multi-website user support via UserMemberships
✅ Materialized view (ListedProperty) optimizes property queries

================================================================================
WEAKNESSES
================================================================================

❌ NO automatic model-level scoping (ScopedModel concern unused)
❌ Manual where clauses are error-prone and easy to forget
❌ Inconsistent website_id assignment (some models auto-assign, others don't)
❌ Several models have optional website_id (allow null values)
❌ NO test-level tenant isolation enforcement
❌ API security relies only on header validation (no role checking)
❌ No validation that user can access requested website/tenant
❌ Some utility methods missing website_id filter (e.g., Content.to_csv)
❌ No strong params protection against website_id mass assignment

================================================================================
MODELS AND SCOPING STATUS
================================================================================

TENANT-SCOPED MODELS (require where(website_id: ...) filtering):
- Pwb::Page                 (no auto-assignment)
- Pwb::Content              (no auto-assignment)
- Pwb::Contact              (optional website, no auto-assignment)
- Pwb::Message              (optional website, no auto-assignment)
- Pwb::Prop (legacy)        (optional website, no auto-assignment)
- Pwb::ListedProperty       (optional website, no auto-assignment)
- Pwb::RealtyAsset          (optional website)
- Pwb::PageContent          (scoped via associations)
- Pwb::PagePart             (scoped via associations)
- Pwb::Link                 (optional website)
- Pwb::WebsitePhoto         (optional website)
- Pwb::SaleListing          (optional website)
- Pwb::RentalListing        (optional website)

SPECIAL MODELS:
- Pwb::Website              (IS the tenant, don't filter)
- Pwb::User                 (can belong to multiple websites)
- Pwb::UserMembership       (links users to websites)
- Pwb::Agency               (one per website)

================================================================================
ACTS_AS_TENANT GEM EVALUATION
================================================================================

VERDICT: NOT RECOMMENDED in current state

REASONS:
1. Would break existing .unscoped() calls in TenantAdmin
2. Performance impact on all queries (default_scope anti-pattern)
3. Incompatible with multi-membership users
4. Makes tests harder to write
5. No compelling safety improvement over current approach

ALTERNATIVE (RECOMMENDED):
1. Enforce website_id auto-assignment (before_validation)
2. Add explicit scope methods: scope :for_website, ->(w) { where(website_id: w.id) }
3. Implement tenant isolation tests
4. Add strong params filtering to prevent website_id assignment
5. Validate user can access website before processing

================================================================================
CROSS-TENANT DATA LEAKAGE RISKS
================================================================================

CRITICAL RISK AREAS:

1. Forgetting website_id filter
   Risk: HIGH if query methods exist without filtering
   Example: Pwb::Page.all or Pwb::Page.find(id) without where clause
   Mitigation: Always use: where(website_id: current_website.id)

2. Null website_id values
   Risk: MEDIUM - could query across "unowned" records
   Example: Contact.where(website_id: nil) would return shared data
   Mitigation: Make website_id NOT NULL or validate presence

3. API header spoofing
   Risk: LOW-MEDIUM - X-Website-Slug header not validated against user
   Example: User from site1 requests site2 data via header
   Mitigation: Validate header against user's accessible websites

4. Service/Job unscoped queries
   Risk: MEDIUM - background jobs might not set Pwb::Current.website
   Example: Background job queries without website_id filter
   Mitigation: Always explicitly pass website/tenant context

5. Mass assignment of website_id
   Risk: LOW - Rails mass assignment protection helps
   Example: params.require(:page).permit(:title, :website_id)
   Mitigation: Exclude website_id from permitted params

SAFEGUARDS IN PLACE:
- Subdomain routing makes mismatches visible
- Controller filtering is pervasive and mostly followed
- No "default" shared data (each model requires explicit filtering)
- Devise authentication prevents unauthenticated access
- TenantAdmin features intentionally use .unscoped() with authorization

================================================================================
KEY FILES INVOLVED
================================================================================

CORE TENANCY:
/app/controllers/concerns/subdomain_tenant.rb    - Tenant resolution
/app/models/pwb/current.rb                       - Thread-local storage
/app/controllers/site_admin_controller.rb        - Single-tenant admin base
/app/models/pwb/website.rb                       - The tenant model

SCOPING (Unused):
/app/models/pwb_tenant/scoped_model.rb          - Automatic scoping (NOT used)

EXAMPLES OF PROPER SCOPING:
/app/controllers/site_admin/messages_controller.rb
/app/models/pwb/page.rb
/app/models/pwb/content.rb

MULTI-WEBSITE SUPPORT:
/app/models/pwb/user.rb
/app/models/pwb/user_membership.rb

API/GRAPHQL:
/app/graphql/types/query_type.rb

================================================================================
RECOMMENDED ACTIONS (PRIORITY ORDER)
================================================================================

PRIORITY 1 (Do immediately):
1. Add before_validation :set_current_website to all tenant models
   - Ensures website_id is always set on creation
   - Reduces manual assignment burden
   
2. Create tenant isolation test suite
   - Test that queries in subdomain1 don't leak to subdomain2
   - Test GraphQL X-Website-Slug header isolation
   
3. Validate user can access website before processing
   - Prevent API header spoofing
   - Add role checking

PRIORITY 2 (Next sprint):
1. Create helper method for safe queries
   def scoped_for_website(model_class)
     model_class.where(website_id: current_website&.id)
   end
   
2. Add strong params filtering
   - Prevent mass assignment of website_id
   
3. Document tenancy patterns (add to README)
   - Link to MULTI_TENANCY_QUICK_REFERENCE.md

PRIORITY 3 (Nice to have):
1. Evaluate acts_as_tenant after implementing Priority 1
2. Add Pundit authorization for role-based access
3. Create explicit scope methods on models:
   scope :for_website, ->(w) { where(website_id: w.id) }

================================================================================
CONCLUSION
================================================================================

PropertyWebBuilder uses a FUNCTIONAL but MANUAL approach to multi-tenancy.
The SubdomainTenant + thread-local storage pattern is solid, but relies on
developer discipline to apply where(website_id: ...) filtering consistently.

The unused ScopedModel concern suggests the team chose explicit control over
automatic scoping. This is reasonable but creates risk if conventions aren't
followed.

CURRENT STATE: Works well IF developers follow conventions
RISK LEVEL: MEDIUM (enforcement mechanisms missing)
RECOMMENDATION: Strengthen with automated enforcement (Priority 1)

See detailed analysis documents for specific code patterns and examples.

================================================================================
